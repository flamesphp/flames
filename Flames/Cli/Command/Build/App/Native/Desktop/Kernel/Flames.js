// Autogenerated by Flames
// Github: https://github.com/flamesphp/flames
// Docs:   https://flamesphp.com

const flames = require('./Flames');
const setup = require('./Setup');
const { app } = require('electron');
const env = require('./../env');
const { exec } = require('child_process');

const BRIDGE_DELAY = 10;

exports.inject = (view) => {
    const payload = setup.getInfo();
    const promise = view.webContents.executeJavaScript('try { window.Flames = window.Flames || {}; window.Flames.__nativeInfo__ = \'' + btoa(JSON.stringify(payload)) + '\'; window.Flames.__nativeInfoDelegate__(); } catch (e) {}');
    promise.catch(function(error) {
        setTimeout(function () {
            flames.messageBridge(view);
        }, BRIDGE_DELAY);
    });
    promise.then(function(result) {
        setTimeout(function () {
            flames.messageBridge(view);
        }, BRIDGE_DELAY);
    });

};

exports.messageBridge = (view) => {
    if (view.webContents === undefined || view.webContents === null) {
        return;
    }

    const promise = view.webContents.executeJavaScript('(function() { try { return window.Flames.Internal.nativeBridgeRequest(); } catch (e) { return null; } })()');
    promise.catch(function(error) {
        setTimeout(function () {
            flames.messageBridge(view);
        }, BRIDGE_DELAY);
    })
    promise.then(function(result) {
        if (result === null){
            setTimeout(function () {
                flames.messageBridge(view);
            }, BRIDGE_DELAY);
            return;
        }

        const data = JSON.parse(atob(result));
        if (data.id === undefined || data.action === undefined) {
            setTimeout(function () {
                flames.messageBridge(view);
            }, BRIDGE_DELAY);
            return;
        }

        flames.onMessageBridge(view, data);

        setTimeout(function () {
            flames.messageBridge(view);
        }, BRIDGE_DELAY);
    });
};

exports.onMessageBridge = (view, data) => {
    let message = null;
    let actionFound = false;

    if (data.action === 'devtools-open') {
        message = flames.actionDevtoolsOpen(view);
        actionFound = true;
    }
    else if (data.action === 'devtools-close') {
        message = flames.actionDevtoolsClose(view);
        actionFound = true;
    }
    else if (data.action === 'exit') {
        message = flames.actionExit(view);
        actionFound = true;
    }
    else if (data.action === 'eval') {
        message = flames.actionEval(view, data);
        actionFound = true;
    }
    else if (data.action === 'shell') {
        message = flames.actionShell(view, data);
        actionFound = true;
    }

    if (actionFound === false) {
        message = {
            error: 'Action not found',
            action: data.action
        };
    }

    if (message === null) {
        return;
    }

    const messagePack = btoa(JSON.stringify(message));
    const promise = view.webContents.executeJavaScript('window.Flames.Internal.nativeBridgeMessage("' + data.id + '", "' + messagePack + '");');
    promise.catch(function(error) {})
    promise.then(function(result) {});
}

exports.actionDevtoolsOpen = (view) => {
    view.webContents.openDevTools({ mode: 'bottom' });
    return {};
}

exports.actionDevtoolsClose = (view) => {
    view.webContents.closeDevTools();
    return {};
}

exports.actionExit = () => {
    app.exit();
    return null;
}

exports.actionEval = (view, data) => {
    if (data.params === null || data.params.appNativeKey === null || data.params.code === null || data.params.appNativeKey !== env.appNativeKey) {
        return null;
    }

    const promise = view.webContents.executeJavaScript('window.location.host;');
    promise.catch(function(error) {})
    promise.then(function(result) {
        if (result === null || result === undefined || result === '') {
            return;
        }

        let domains = env.domains.split(',');
        if (domains.includes(result) === false) {
            return;
        }

        flames.actionEvalPost(view, data);
    });


    return null;
}

exports.actionEvalPost = (view, data) => {
    let code = atob(data.params.code);

    let message = null;
    try {
        let _return = eval(code);

        message = {
            message: _return
        }
    } catch (error) {
        message = {
            error: 'Evaluate error',
            message: error.stack
        }
    }

    const messagePack = btoa(JSON.stringify(message));
    const promise = view.webContents.executeJavaScript('window.Flames.Internal.nativeBridgeMessage("' + data.id + '", "' + messagePack + '");');
    promise.catch(function(error) {})
    promise.then(function(result) {});
}

exports.actionShell = (view, data) => {
    if (data.params === null || data.params.appNativeKey === null || data.params.code === null || data.params.appNativeKey !== env.appNativeKey) {
        return null;
    }

    const promise = view.webContents.executeJavaScript('window.location.host;');
    promise.catch(function(error) {})
    promise.then(function(result) {
        if (result === null || result === undefined || result === '') {
            return;
        }

        let domains = env.domains.split(',');
        if (domains.includes(result) === false) {
            return;
        }

        flames.actionShellPost(view, data);
    });


    return null;
}

exports.actionShellPost = (view, data) => {
    let command = atob(data.params.command);

    exec(command, (error, outputBuffer, outputError) => {
        let message = {}

        if (error) {
            message.error = 'Shell error';
            message.message = error.message;
        }
        else if (outputError) {
            message.error = 'Shell error';
            message.message = outputError;
        } else {
            message.message = outputBuffer;
        }

        const messagePack = btoa(JSON.stringify(message));
        const promise = view.webContents.executeJavaScript('window.Flames.Internal.nativeBridgeMessage("' + data.id + '", "' + messagePack + '");');
        promise.catch(function(error) {})
        promise.then(function(result) {});
    });
}